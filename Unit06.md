---
layout: default
title: "CS302: Software Engineering"
course_description: "A detailed introduction to the application of engineering approach to computer software design and development. Topics include life cycle models, software requirements, specification, conceptual model design, detailed design, validation and verification, design quality assurance, software design/development environments, and project management."
next: ../Unit07
previous: ../Unit05
---
**Unit 6: Software Design** <span id="6"></span> 
*After requirements and analysis, a software engineer must transform the
analysis model into a design model that can be implemented in a specific
hardware and software environment. In this unit, we will discuss the
principles of design and architecture design. Just as there are various
methodologies for requirements analysis, we will drill down from the
analysis model(s) to the design model(s) following the three
corresponding methodologies (i.e., data-oriented, process-oriented, and
object-oriented). *  
    
 *As you review the material in this unit, spend some time on the
object-oriented methodology as it applies to software design. You will
be applying this in a later unit to put it all together in a case
study.*

**Unit 6 Time Advisory**  
Completing this unit will take you approximately 26.75 hours.  
  
 <span
style="color: rgb(85, 85, 85); font-family: 'Myriad Pro', 'Gill Sans', 'Gill Sans MT', Calibri, sans-serif; font-size: 16px; line-height: 24px;">☐
   </span>Subunit 6.1: 0.75 hours  
  
 <span
style="color: rgb(85, 85, 85); font-family: 'Myriad Pro', 'Gill Sans', 'Gill Sans MT', Calibri, sans-serif; font-size: 16px; line-height: 24px;">☐
   </span>Subunit 6.2: 2 hours  
  
 <span
style="color: rgb(85, 85, 85); font-family: 'Myriad Pro', 'Gill Sans', 'Gill Sans MT', Calibri, sans-serif; font-size: 16px; line-height: 24px;">☐
   </span>Subunit 6.3.1: 7 hours  
  
 <span
style="color: rgb(85, 85, 85); font-family: 'Myriad Pro', 'Gill Sans', 'Gill Sans MT', Calibri, sans-serif; font-size: 16px; line-height: 24px;">☐
   </span>Subunit 6.3.2: 9 hours  
  
 <span
style="color: rgb(85, 85, 85); font-family: 'Myriad Pro', 'Gill Sans', 'Gill Sans MT', Calibri, sans-serif; font-size: 16px; line-height: 24px;">☐
   </span>Subunit 6.3.3: 8 hours

**Unit6 Learning Outcomes**  
Upon successful completion of this unit, you will be able to:  
-   define software design principles;
-   discuss architectural design in terms of decisions, system
    organization, modular decomposition, and flow-and-control; and
-   list the design activities and their major representations in
    data-oriented, process-oriented, and object-oriented methodologies.

**6.1 Software Design Principles (Information Hiding, Cohesion,
Coupling)** <span id="6.1"></span> 
-   **Reading: The Global Text Project: Sue Conger’s *The New Software
    Engineering*: “Chapter 8 Process-Oriented Design”**
    Link: The Global Text Project: Sue Conger’s [*The New Software
    Engineering*](http://globaltext.terry.uga.edu/booklist?cat=Computing):
    “Chapter 8 Process-Oriented Design” (PDF)  
        
     Instructions: Read the section titled “Conceptual Foundations” in
    Chapter 8 (pages 279–280). The principles of good software design
    have not changed much over the years. In design, we aim to divide
    and conquer the problem space into smaller solvable parts to better
    manage complexity and, therefore, cost of development/
    maintenance.  
        
     Reading this this selection, taking notes, and taking time to
    comprehend should take approximately 45 minutes.  
        
     Terms of Use: This resource is available under a [Creative Commons
    Attribution 3.0 Unported
    License](http://creativecommons.org/licenses/by/3.0/). It is
    attributed to Sue Conger and The Global Text Project, and it may be
    found in its original form
    [here](http://dl.dropbox.com/u/31779972/The%20New%20Software%20Engineering.pdf).

**6.2 Architectural Design** <span id="6.2"></span> 
-   **Web Media: Carnegie Mellon Software Engineering Institute: Paul
    Clement’s “Best Practices in Software Architecture”**
    Link: Carnegie Mellon Software Engineering Institute: Paul
    Clement’s [“Best Practices in Software
    Architecture”](http://www.sei.cmu.edu/library/abstracts/podcasts/clementsdlseries.cfm) (MP3)  
        
     Instructions: Listen to the architecture portion of the podcast
    (first 45 minutes). This audio introduces the fundamentals of
    software architecture design, including runtime and non-runtime
    qualities, architectural building blocks, etc. The material is not
    intended to be a step-by-step *how to* for performing architectural
    design (which is a huge topic), but rather to induce an appreciation
    for architectural design when it is done right. Pause as necessary
    for note-taking.  
        
     Listening to this web media,taking notes, and taking time to
    comprehend should take approximately 2 hours.  
        
     Terms of Use: Please respect the copyright and terms of use
    displayed on the webpage above.

**6.3 Software Design Approaches** <span id="6.3"></span> 
**6.3.1 Process-Oriented Design** <span id="6.3.1"></span> 
-   **Reading: The Global Text Project: Sue Conger’s *The New Software
    Engineering*: “Chapter 8: Process-Oriented Design”**
    Link: The Global Text Project: Sue Conger’s [*The New Software
    Engineering*](http://dl.dropbox.com/u/31779972/The%20New%20Software%20Engineering.pdf):
    “Chapter 8: Process-Oriented Design” (PDF)  
        
     Instructions: Read “Chapter 8: Process-Oriented Design” (pages
    278-327). The goal of design is to map the requirements of the
    application to a hardware and software environment. The result of
    process-oriented analysis—data flow diagrams, data dictionary
    entities, etc.—is translated into detailed specifications for
    hardware and software. The main output of process-oriented design
    includes structure charts, physical databases, and program
    specifications.  
      
     In this reading, you will learn about the concepts and
    terminologies for process-oriented design. This reading covers the
    steps of process-oriented design including transaction analysis,
    transform analysis, and structure charts, as well as physical
    database design, program packages, and program design. You will also
    learn about strengths and weaknesses of process-oriented
    design. Take your time in reading and jot down any ideas or notes
    that stand out to you as particularly useful (or, conversely,
    confusing).  
        
     Reading this selection, taking notes, and taking time to
    comprehendshould take approximately 7 hours.  
        
     Terms of Use: This resource is available under a [Creative Commons
    Attribution 3.0 Unported
    License](http://creativecommons.org/licenses/by/3.0/). It is
    attributed to Sue Conger and The Global Text Project, and it may be
    found in its original
    form [here](http://dl.dropbox.com/u/31779972/The%20New%20Software%20Engineering.pdf).

**6.3.2 Data-Oriented Design** <span id="6.3.2"></span> 
-   **Reading: The Global Text Project: Sue Conger’s *The New Software
    Engineering*: “Chapter 10: Data-Oriented Design”**
    Link: The Global Text Project: Sue Conger’s [*The New Software
    Engineering*](http://dl.dropbox.com/u/31779972/The%20New%20Software%20Engineering.pdf):
    “Chapter 10: Data-Oriented Design” (PDF)  
        
     Instructions: Read “Chapter 10: Data-Oriented Design” (pages
    391-458). The text uses the Martin [1990] version of *Information
    Engineering* to illustrate data-oriented design. The result of
    data-oriented analysis—entity relationship diagrams, data flow
    diagrams, CRUD matrices, etc.—is translated into screen designs,
    production database designs, action diagrams, procedural structures,
    and security plans. Compared to other approaches, data-oriented
    design has a strong emphasis on security, recovery, and audit
    controls, relating each to data and processes in the application.  
        
     In this reading, you will learn about the concepts and
    terminologies for data-oriented design, analyzing data and defining
    system controls, and the action diagram. The action diagram shows
    the processing details for an application in a structured format,
    which can be translated into programs and modules. You will also
    learn about menu structure, dialogue flow and hardware/software
    installation and testing in this reading. Take your time in reading
    and jot down any ideas or notes that stand out to you as
    particularly useful (or, conversely, confusing).  
        
     Reading this selection, taking notes, and taking time to comprehend
    should take approximately 9 hours.  
        
     Terms of Use: This resource is available under a [Creative Commons
    Attribution 3.0 Unported
    License](http://creativecommons.org/licenses/by/3.0/). It is
    attributed to Sue Conger and The Global Text Project, and it may be
    found in its original form
    [here](http://dl.dropbox.com/u/31779972/The%20New%20Software%20Engineering.pdf).

**6.3.3 Object-Oriented Design OOD** <span id="6.3.3"></span> 
-   **Reading: The Global Text Project: Sue Conger’s *The New Software
    Engineering*: “Chapter 12: Object-Oriented Design”**
    Link: The Global Text Project: Sue Conger’s [*The New Software
    Engineering*](http://dl.dropbox.com/u/31779972/The%20New%20Software%20Engineering.pdf):
    “Chapter 12: Object-Oriented Design” (PDF)  
        
     Instructions: Please read “Chapter 12: Object-Oriented Design”
    (pages 501-553). The text uses the Booch methodology (1991) to
    illustrate object-oriented design. The result of object-oriented
    analysis is translated into time-event diagrams, Booch diagrams,
    message communications, service objects, and process diagrams.
    Collectively, they constitute a set of holistic specifications to
    effectively allocate functionality over program modules at the
    lowest level as well as multiprocessor configurations at the highest
    level. As discussed in subunit 5.3.3, the Booch notation has been
    unified with other object-oriented notations (i.e., Rambaugh and
    Jacobsen) into Unified Modeling Language (UML). In Unit 10, we will
    look at another example of object-oriented analysis and design using
    the UML notation. Therefore, you may skim this chapter quickly to
    gain familiarity with OOD, which you will apply to Unit 10. Take
    your time in reading and jot down any ideas or notes that stand out
    to you as particularly useful (or, conversely, confusing).  
        
     Reading this selection, taking notes, and taking time to comprehend
    should take approximately 7 hours.  
        
     Terms of Use: This resource is available under a [Creative Commons
    Attribution 3.0 Unported
    License](http://creativecommons.org/licenses/by/3.0/). It is
    attributed to Sue Conger and The Global Text Project, and it may be
    found in its original
    form [here](http://dl.dropbox.com/u/31779972/The%20New%20Software%20Engineering.pdf).

-   **Assessment: The Saylor Foundation’s “Unit 6 Checkpoint”**
    Link: The Saylor Foundation’s [“Unit 6
    Checkpoint”](http://www.saylor.org/site/wp-content/uploads/2013/10/CS302-OC-Unit-6-PRVFINAL.pdf) (PDF)  
        
     Instructions: Complete this assessment. When you have completed the
    assessment, check your answers against the [“Unit 6 Checkpoint Guide
    to
    Responding”](http://www.saylor.org/site/wp-content/uploads/2013/10/CS302-OC-Unit-6-Answer_Key-PRVFINAL.pdf).  
        
     Completing this assignment should take approximately 1 hour.


